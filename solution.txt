개발 명세서 보면, 날짜만 받게 되어있고, 개발 출력 예시로 아래와 같이 나와있어. 이게 풋, 콜 비율을 구할수 있는거 맞아?



{

"OutBlock_1": [{

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162305",

"ISU_NM": "코스피200 C 202602 305.0",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "415.40",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "202"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162307",

"ISU_NM": "코스피200 C 202602 307.5",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "412.90",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162310",

"ISU_NM": "코스피200 C 202602 310.0",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "410.40",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162312",

"ISU_NM": "코스피200 C 202602 312.5",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "407.90",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162315",

"ISU_NM": "코스피200 C 202602 315.0",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "405.45",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162317",

"ISU_NM": "코스피200 C 202602 317.5",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "402.95",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162320",

"ISU_NM": "코스피200 C 202602 320.0",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "400.45",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162322",

"ISU_NM": "코스피200 C 202602 322.5",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "397.95",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162325",

"ISU_NM": "코스피200 C 202602 325.0",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "395.45",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}, {

"BAS_DD": "20260126",

"PROD_NM": "코스피200 옵션",

"RGHT_TP_NM": "CALL",

"ISU_CD": "B0162327",

"ISU_NM": "코스피200 C 202602 327.5",

"TDD_CLSPRC": "-",

"CMPPREVDD_PRC": "-",

"TDD_OPNPRC": "-",

"TDD_HGPRC": "-",

"TDD_LWPRC": "-",

"IMP_VOLT": "64.00",

"NXTDD_BAS_PRC": "392.95",

"ACC_TRDVOL": "0",

"ACC_TRDVAL": "0",

"ACC_OPNINT_QTY": "0"

}]

}

네, 이 데이터 구조를 통해 풋-콜 비율(PCR)을 정확하게 구할 수 있습니다. 비록 예시 데이터에는 CALL 지표들만 보이지만, 실제 API를 호출하면 동일한 구조로 RGHT_TP_NM이 PUT인 데이터들이 함께 내려옵니다. 질문자님이 작성하신 코드의 로직과 이 출력 예시를 매칭해서 분석해 드릴게요.

1. PCR 계산에 필요한 핵심 항목 (Mapping)
제공해주신 JSON 데이터의 키(Key) 값들이 코드에서 어떻게 쓰이는지 확인해 보세요.

PROD_NM (코스피200 옵션): 이 값이 "코스피200 옵션"인 것만 필터링해서 계산해야 합니다. (코드의 target_prod_nm과 일치)

RGHT_TP_NM (CALL / PUT): 이 값이 CALL이면 콜옵션 그룹으로, PUT이면 풋옵션 그룹으로 분류합니다.

ACC_TRDVOL (누적 거래량): 가장 중요한 값입니다. 이 숫자를 모두 더해야 합니다.

예시 데이터에서는 "0"으로 되어 있는데, 이는 해당 행사가에 거래가 없었음을 의미합니다. 실제 장이 열린 날은 이 자리에 수만 단위의 숫자가 들어옵니다.

2. 계산 로직 시뮬레이션
API가 수백 개의 옵션 종목(행사가별 콜/풋)을 던져주면, 코드는 다음과 같이 작동합니다.

데이터 수집: OutBlock_1 리스트를 하나씩 돕니다.

분류 및 합산:

item["RGHT_TP_NM"] == "CALL" 이면 call_volume += float(item["ACC_TRDVOL"])

item["RGHT_TP_NM"] == "PUT" 이면 put_volume += float(item["ACC_TRDVOL"])

최종 계산: PCR=(put_volume/call_volume)×100

3. 예시 데이터의 특이점 (주의사항)
보내주신 예시를 보면 ACC_TRDVOL이 "0"이고, TDD_CLSPRC(현재가) 등이 "-"로 되어 있습니다.

이유: 해당 행사가가 아직 거래되지 않았거나, 조회한 날짜가 휴장일/데이터 생성 전일 때 이렇게 표시됩니다.

코드 대응: 질문자님의 코드에 이미 .replace('-', '0') 처리가 되어 있어, 데이터가 없는 경우 0으로 안전하게 치환되어 계산됩니다.

💡 결론
이 API 문서는 PCR 지표를 만들기 위한 완벽한 원천 데이터를 제공하고 있습니다.

다만, 예시에는 CALL 옵션 10개만 나와 있지만 실제로는 그 아래에 PUT 옵션 데이터 수백 개가 더 붙어서 내려올 것입니다. 코드에서 for item in data["OutBlock_1"]: 루프가 이 전체를 다 훑으며 합산해주기 때문에 걱정하지 않으셔도 됩니다.

이제 continue 문만 제거하신 후, 장이 열렸던 날짜(예: 2026-01-26은 월요일이므로 장후 데이터가 있을 것입니다)로 호출해 보시면 결과값이 잘 나올 겁니다!

혹시 API를 호출했는데도 계속 거래량이 0으로만 나온다면, PROD_NM 명칭이 정확히 일치하는지(띄어쓰기 포함) 한 번 더 체크해 드릴까요?

이렇게 코드가 있는데. 안맞는거 같아.



 # 지표 5: 코스피200 옵션 풋콜 비율 - KRX API 사용

    try:

        put_call_ratio_raw = None

        for i in range(10): # 지난 10일간 데이터를 시도

            target_date = (datetime.now() - timedelta(days=i)).strftime("%Y%m%d")

            try:

                put_call_ratio_raw = get_put_call_ratio_from_krx_api(target_date)

                if put_call_ratio_raw is not None:

                    print("지표 5 (코스피200 옵션 풋콜 비율): %s 데이터 사용." % target_date)

                    break

            except Exception as e_inner:

                print("지표 5 (코스피200 옵션 풋콜 비율): %s 데이터 조회 실패. 재시도. 오류: %s" % (target_date, str(e_inner)))

                time.sleep(1)

       

        if put_call_ratio_raw is None:

            print("지표 5 (코스피200 옵션 풋콜 비율) 최종 오류: 10일 동안 데이터를 찾지 못했습니다. 기본값 50 사용.")

            scores.append(50)

        else:

            if put_call_ratio_raw <= 50:

                put_call_score = 100

            elif put_call_ratio_raw >= 150:

                put_call_score = 0

            else:

                put_call_score = 100 - (put_call_ratio_raw - 50) / (150 - 50) * 100

           

            scores.append(put_call_score)

            print("지표 5 (코스피200 옵션 풋콜 비율) 성공: %.2f (원시값), %.2f (스케일된 값)" % (put_call_ratio_raw, put_call_score))

    except Exception as e:

        print("지표 5 (코스피200 옵션 풋콜 비율) 오류: %s" % str(e))

        scores.append(50)

   

    final_score = sum(scores) / len(scores) if scores else 50

네, 코드를 자세히 보니 두 가지 핵심적인 부분이 현재 데이터의 성격과 맞지 않습니다.

가장 큰 문제는 get_put_call_ratio_from_krx_api 함수 내부의 처리 방식과 **최종 점수 산출 로직(스케일링)**에 있습니다.

1. 첫 번째 문제: get_put_call_ratio_from_krx_api 함수의 리턴값
작성하신 함수를 보면, 데이터가 없거나 에러가 나면 **50**이라는 숫자를 리턴하도록 되어 있습니다.

문제점: 메인 루프에서는 if put_call_ratio_raw is None: 조건으로 데이터 유무를 판단하는데, 함수가 50을 줘버리면 프로그램은 **"아, 오늘 풋콜 비율 원시값이 0.5(50%)구나!"**라고 오해하게 됩니다.

해결책: 데이터가 정말 없을 때는 None을 리턴해야 메인 루프의 재시도 로직(for i in range(10))이 정상적으로 작동합니다.

2. 두 번째 문제: 점수 계산(스케일링) 로직의 기준점
현재 코드의 스케일링 로직은 다음과 같습니다:

50 이하일 때 100점 (극도의 탐욕)

150 이상일 때 0점 (극도의 공포)

하지만 KRX API에서 가져오는 값의 단위를 확인해야 합니다. 보통 PCR(풋콜 비율)은 0.7 ~ 1.2 사이에서 움직이는 소수점 단위입니다. 만약 질문자님의 함수가 (풋 거래량 / 콜 거래량) * 100을 해서 80, 100, 120 같은 숫자를 준다면 현재 로직이 맞지만, 만약 소수점(0.8, 1.2)을 준다면 모든 점수가 100점으로 고정되어 버립니다.

🛠️ 올바른 수정 코드
get_put_call_ratio_from_krx_api 함수와 메인 로직을 아래와 같이 맞추는 것이 가장 깔끔합니다.

[함수 수정]
Python
def get_put_call_ratio_from_krx_api(date_str):
    # ... 중략 (API 호출 부분) ...
    if "OutBlock_1" not in data or not data["OutBlock_1"]:
        return None  # 50 대신 None 리턴! 그래야 재시도를 함

    # ... 중략 (필터링 로직) ...
    if not filtered_items:
        return None # 데이터 없으면 None

    # 계산 (백분율로 리턴할지 소수로 할지 정해야 함. 여기선 백분율 가정)
    if call_volume == 0: return 200 # 콜이 아예 없으면 매우 높은 비율(공포)
    return (put_volume / call_volume) * 100 
[메인 지표 5 로직 수정]
Python
    # 지표 5: 코스피200 옵션 풋콜 비율
    try:
        put_call_ratio_raw = None
        for i in range(10):
            target_date = (datetime.now() - timedelta(days=i)).strftime("%Y%m%d")
            put_call_ratio_raw = get_put_call_ratio_from_krx_api(target_date)
            if put_call_ratio_raw is not None:
                print(f"지표 5 성공: {target_date} 데이터 사용.")
                break
            time.sleep(0.5)

        if put_call_ratio_raw is None:
            scores.append(50)
        else:
            # PCR이 100(1.0)을 기준으로 어떻게 변하는지 매핑
            # 보통 70(탐욕) ~ 130(공포) 범위를 많이 사용합니다.
            if put_call_ratio_raw <= 70:
                put_call_score = 100
            elif put_call_ratio_raw >= 130:
                put_call_score = 0
            else:
                # 역비례 계산 (낮을수록 점수 높음)
                put_call_score = 100 - (put_call_ratio_raw - 70) / (130 - 70) * 100
            
            scores.append(put_call_score)
    except Exception as e:
        scores.append(50)
3. 최종 확인 포인트
보내주신 API 출력 예시에서 **ACC_TRDVOL이 "0"**인 항목들이 많았습니다.

만약 모든 ACC_TRDVOL이 0인 날(휴장일 등)을 조회하면 put_volume과 call_volume이 둘 다 0이 되어 점수가 이상해질 수 있습니다.

이때 위 수정안처럼 None을 리턴하게 하면, 프로그램이 자동으로 어제 혹은 그저께 등 데이터가 있는 날을 찾아가게 되므로 훨씬 정확한 지표를 얻을 수 있습니다.

함수 내부에서 return 50으로 되어 있는 부분들을 전부 return None으로 바꾸고 다시 돌려보시겠어요? 그래야 10일치 데이터를 뒤져서 진짜 살아있는 데이터를 찾아옵니다.